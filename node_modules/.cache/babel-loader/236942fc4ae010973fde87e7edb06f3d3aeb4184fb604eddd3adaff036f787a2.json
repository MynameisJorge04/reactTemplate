{"ast":null,"code":"import _slicedToArray from\"/home/jorgebg/personalProjects/cursoReact/cursoReactIntroduccion/todo-machine/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";import React from'react';//Podemos empezar a hacer hoooks como queramos\nfunction useLocalStorage(itemName,initialValue){//Cuando tengamos algo de infromaicon dentro de nuestro estado porque ya acabo de cargar entonces pasamos a la aplicacion\nvar _React$useState=React.useState(false),_React$useState2=_slicedToArray(_React$useState,2),error=_React$useState2[0],setError=_React$useState2[1];//Cuando tengamos algo de infromaicon dentro de nuestro estado porque ya acabo de cargar entonces pasamos a la aplicacion\nvar _React$useState3=React.useState(true),_React$useState4=_slicedToArray(_React$useState3,2),loading=_React$useState4[0],setLoading=_React$useState4[1];//Ya no traeremos por defecto la informacacion storage si nho lo definido\nvar _React$useState5=React.useState(initialValue),_React$useState6=_slicedToArray(_React$useState5,2),item=_React$useState6[0],setItem=_React$useState6[1];//Lo que haremos es simular que tardara un rato en llegar\nReact.useEffect(function(){//Cantidad de tiempo hasta ejecutar la funcion\nsetTimeout(function(){try{//Vamos a hacer un try catch, que consiste en una condicion de error, y ejecuta cierta parte de codigo\n//Casi siempre las APIS tienen ciertas versiones\nvar localStorageItem=localStorage.getItem(itemName);//Crear un primer array vacio con cosas vacias, tenbemos que traer la info guardada en local storage\nvar parsedItem;//Vemos si tiene informacion\nif(!localStorageItem){//Por defecto una lista de todos necesitamos enmviar un string\nlocalStorage.setItem(itemName,JSON.stringify(initialValue));parsedItem=initialValue;}//Ya tiene algunos todos\nelse{parsedItem=JSON.parse(localStorageItem);}//Nuestro estado es el inical al tener un array vacio, lo que hace es dar el nuevo valor en localstorage\nsetItem(parsedItem);setLoading(false);}catch(error){//Tomamos en cuenta que los errores son falsos\nsetError(error);}},1000);});//Para la persistencia cada cambio debemos llamar nuestro local storage para persistencia\nvar saveItem=function saveItem(newItem){try{//Envolvemos a nuestros items por si hay algun error tambien\nvar stringifiedItem=JSON.stringify(newItem);//HAY QUE PERSISTIR la informacion\nlocalStorage.setItem(itemName,stringifiedItem);//Debemos evitar la actualizacion de la pagina\nsetItem(newItem);}catch(error){setError(error);}};//Necesitamos retornar localStorage, es importante tomar en cuenta que si hay mas estados que dos en un hook devolvemos un objeto\nreturn{item:item,saveItem:saveItem,loading:loading,error:error};}export{useLocalStorage};// import React from 'react';\n// //Podemos empezar a hacer hoooks como queramos\n// function useLocalStorage(itemName, initialValue) {\n//     //Cuando tengamos algo de infromaicon dentro de nuestro estado porque ya acabo de cargar entonces pasamos a la aplicacion\n//     const [loading, setLoading] = React.useState(true);\n//     //Cuando tengamos algo de infromaicon dentro de nuestro estado porque ya acabo de cargar entonces pasamos a la aplicacion\n//     const [error, setError] = React.useState(false);\n//     //Ya no traeremos por defecto la informacacion storage si nho lo definido\n//     const [item, setItem] = React.useState(initialValue);\n//     //Lo que haremos es simular que tardara un rato en llegar\n//     React.useEffect(() => {\n//       //Cantidad de tiempo hasta ejecutar la funcion\n//       setTimeout(() => {\n//         //Vamos a hacer un try catch, que consiste en una condicion de error, y ejecuta cierta parte de codigo\n//         try{\n//           //Casi siempre las APIS tienen ciertas versiones\n//         const localStorageItem = localStorage.getItem(itemName);\n//         //Crear un primer array vacio con cosas vacias, tenbemos que traer la info guardada en local storage\n//         let parsedItem;\n//         //Vemos si tiene informacion\n//         if (!localStorageItem) {\n//           //Por defecto una lista de todos necesitamos enmviar un string\n//           localStorage.setItem(itemName, JSON.stringify(initialValue));\n//           parsedItem = initialValue;\n//         }\n//         //Ya tiene algunos todos\n//         else {\n//           parsedItem = JSON.parse(localStorageItem);\n//         }\n//         //Nuestro estado es el inical al tener un array vacio, lo que hace es dar el nuevo valor en localstorage\n//         setTimeout(parsedItem);\n//         setLoading(false);\n//         } catch(error){\n//           //Tomamos en cuenta que los errores son falsos\n//           setError(error);\n//         }\n//       }, 1000);\n//     });\n//     //Para la persistencia cada cambio debemos llamar nuestro local storage para persistencia\n//     const savedItem = (newItem) => {\n//       //Envolvemos a nuestros items por si hay algun error tambien\n//       try{\n//         //HAY QUE PERSISTIR la informacion\n//       const stringifiedItem = JSON.stringify(newItem);\n//       //GUardamos nuestra cadena\n//       localStorage.setItem(itemName, stringifiedItem);\n//       //Debemos evitar la actualizacion de la pagina\n//       setItem(newItem);\n//       } catch(error){\n//         setError(error);\n//       }\n//     };\n//     //Necesitamos retornar localStorage, es importante tomar en cuenta que si hay mas estados que dos en un hook devolvemos un objeto\n//     return {\n//       item, \n//       savedItem, \n//       loading,\n//       error,\n//     };\n//   }\n//   export { useLocalStorage };","map":{"version":3,"names":["React","useLocalStorage","itemName","initialValue","useState","error","setError","loading","setLoading","item","setItem","useEffect","setTimeout","localStorageItem","localStorage","getItem","parsedItem","JSON","stringify","parse","saveItem","newItem","stringifiedItem"],"sources":["/home/jorgebg/personalProjects/cursoReact/cursoReactIntroduccion/todo-machine/src/TodoContext/useLocalStorage.js"],"sourcesContent":["import React from 'react';\n\n//Podemos empezar a hacer hoooks como queramos\nfunction useLocalStorage(itemName, initialValue) {\n  //Cuando tengamos algo de infromaicon dentro de nuestro estado porque ya acabo de cargar entonces pasamos a la aplicacion\n  const [error, setError] = React.useState(false);\n  //Cuando tengamos algo de infromaicon dentro de nuestro estado porque ya acabo de cargar entonces pasamos a la aplicacion\n  const [loading, setLoading] = React.useState(true);\n  //Ya no traeremos por defecto la informacacion storage si nho lo definido\n  const [item, setItem] = React.useState(initialValue);\n  \n  //Lo que haremos es simular que tardara un rato en llegar\n  React.useEffect(() => {\n    //Cantidad de tiempo hasta ejecutar la funcion\n    setTimeout(() => {\n      try {\n        //Vamos a hacer un try catch, que consiste en una condicion de error, y ejecuta cierta parte de codigo\n         //Casi siempre las APIS tienen ciertas versiones\n        const localStorageItem = localStorage.getItem(itemName);\n\n        //Crear un primer array vacio con cosas vacias, tenbemos que traer la info guardada en local storage\n        let parsedItem;\n        \n        //Vemos si tiene informacion\n        if (!localStorageItem) {\n          //Por defecto una lista de todos necesitamos enmviar un string\n          localStorage.setItem(itemName, JSON.stringify(initialValue));\n          parsedItem = initialValue;\n        } \n\n        //Ya tiene algunos todos\n        else {\n          parsedItem = JSON.parse(localStorageItem);\n        }\n        //Nuestro estado es el inical al tener un array vacio, lo que hace es dar el nuevo valor en localstorage\n        setItem(parsedItem);\n        setLoading(false);\n      } catch(error) {\n        //Tomamos en cuenta que los errores son falsos\n        setError(error);\n      }\n    }, 1000);\n  });\n  \n  //Para la persistencia cada cambio debemos llamar nuestro local storage para persistencia\n  const saveItem = (newItem) => {\n    try {\n      //Envolvemos a nuestros items por si hay algun error tambien\n      const stringifiedItem = JSON.stringify(newItem);\n      //HAY QUE PERSISTIR la informacion\n      localStorage.setItem(itemName, stringifiedItem);\n      //Debemos evitar la actualizacion de la pagina\n      setItem(newItem);\n    } catch(error) {\n      setError(error);\n    }\n  };\n\n  //Necesitamos retornar localStorage, es importante tomar en cuenta que si hay mas estados que dos en un hook devolvemos un objeto\n  return {\n    item,\n    saveItem,\n    loading,\n    error,\n  };\n}\n\nexport { useLocalStorage };\n\n\n// import React from 'react';\n\n// //Podemos empezar a hacer hoooks como queramos\n\n// function useLocalStorage(itemName, initialValue) {\n//     //Cuando tengamos algo de infromaicon dentro de nuestro estado porque ya acabo de cargar entonces pasamos a la aplicacion\n//     const [loading, setLoading] = React.useState(true);\n  \n//     //Cuando tengamos algo de infromaicon dentro de nuestro estado porque ya acabo de cargar entonces pasamos a la aplicacion\n//     const [error, setError] = React.useState(false);\n  \n//     //Ya no traeremos por defecto la informacacion storage si nho lo definido\n//     const [item, setItem] = React.useState(initialValue);\n  \n//     //Lo que haremos es simular que tardara un rato en llegar\n//     React.useEffect(() => {\n//       //Cantidad de tiempo hasta ejecutar la funcion\n//       setTimeout(() => {\n//         //Vamos a hacer un try catch, que consiste en una condicion de error, y ejecuta cierta parte de codigo\n  \n//         try{\n//           //Casi siempre las APIS tienen ciertas versiones\n//         const localStorageItem = localStorage.getItem(itemName);\n  \n//         //Crear un primer array vacio con cosas vacias, tenbemos que traer la info guardada en local storage\n//         let parsedItem;\n  \n//         //Vemos si tiene informacion\n//         if (!localStorageItem) {\n//           //Por defecto una lista de todos necesitamos enmviar un string\n//           localStorage.setItem(itemName, JSON.stringify(initialValue));\n//           parsedItem = initialValue;\n//         }\n  \n//         //Ya tiene algunos todos\n//         else {\n//           parsedItem = JSON.parse(localStorageItem);\n//         }\n  \n//         //Nuestro estado es el inical al tener un array vacio, lo que hace es dar el nuevo valor en localstorage\n//         setTimeout(parsedItem);\n//         setLoading(false);\n//         } catch(error){\n//           //Tomamos en cuenta que los errores son falsos\n//           setError(error);\n//         }\n  \n//       }, 1000);\n//     });\n  \n  \n  \n//     //Para la persistencia cada cambio debemos llamar nuestro local storage para persistencia\n//     const savedItem = (newItem) => {\n//       //Envolvemos a nuestros items por si hay algun error tambien\n//       try{\n//         //HAY QUE PERSISTIR la informacion\n//       const stringifiedItem = JSON.stringify(newItem);\n//       //GUardamos nuestra cadena\n//       localStorage.setItem(itemName, stringifiedItem);\n//       //Debemos evitar la actualizacion de la pagina\n//       setItem(newItem);\n//       } catch(error){\n//         setError(error);\n//       }\n//     };\n  \n//     //Necesitamos retornar localStorage, es importante tomar en cuenta que si hay mas estados que dos en un hook devolvemos un objeto\n//     return {\n//       item, \n//       savedItem, \n//       loading,\n//       error,\n//     };\n//   }\n\n//   export { useLocalStorage };"],"mappings":"mKAAA,MAAOA,MAAK,KAAM,OAAO,CAEzB;AACA,QAASC,gBAAe,CAACC,QAAQ,CAAEC,YAAY,CAAE,CAC/C;AACA,oBAA0BH,KAAK,CAACI,QAAQ,CAAC,KAAK,CAAC,oDAAxCC,KAAK,qBAAEC,QAAQ,qBACtB;AACA,qBAA8BN,KAAK,CAACI,QAAQ,CAAC,IAAI,CAAC,qDAA3CG,OAAO,qBAAEC,UAAU,qBAC1B;AACA,qBAAwBR,KAAK,CAACI,QAAQ,CAACD,YAAY,CAAC,qDAA7CM,IAAI,qBAAEC,OAAO,qBAEpB;AACAV,KAAK,CAACW,SAAS,CAAC,UAAM,CACpB;AACAC,UAAU,CAAC,UAAM,CACf,GAAI,CACF;AACC;AACD,GAAMC,iBAAgB,CAAGC,YAAY,CAACC,OAAO,CAACb,QAAQ,CAAC,CAEvD;AACA,GAAIc,WAAU,CAEd;AACA,GAAI,CAACH,gBAAgB,CAAE,CACrB;AACAC,YAAY,CAACJ,OAAO,CAACR,QAAQ,CAAEe,IAAI,CAACC,SAAS,CAACf,YAAY,CAAC,CAAC,CAC5Da,UAAU,CAAGb,YAAY,CAC3B,CAEA;AAAA,IACK,CACHa,UAAU,CAAGC,IAAI,CAACE,KAAK,CAACN,gBAAgB,CAAC,CAC3C,CACA;AACAH,OAAO,CAACM,UAAU,CAAC,CACnBR,UAAU,CAAC,KAAK,CAAC,CACnB,CAAE,MAAMH,KAAK,CAAE,CACb;AACAC,QAAQ,CAACD,KAAK,CAAC,CACjB,CACF,CAAC,CAAE,IAAI,CAAC,CACV,CAAC,CAAC,CAEF;AACA,GAAMe,SAAQ,CAAG,QAAXA,SAAQ,CAAIC,OAAO,CAAK,CAC5B,GAAI,CACF;AACA,GAAMC,gBAAe,CAAGL,IAAI,CAACC,SAAS,CAACG,OAAO,CAAC,CAC/C;AACAP,YAAY,CAACJ,OAAO,CAACR,QAAQ,CAAEoB,eAAe,CAAC,CAC/C;AACAZ,OAAO,CAACW,OAAO,CAAC,CAClB,CAAE,MAAMhB,KAAK,CAAE,CACbC,QAAQ,CAACD,KAAK,CAAC,CACjB,CACF,CAAC,CAED;AACA,MAAO,CACLI,IAAI,CAAJA,IAAI,CACJW,QAAQ,CAARA,QAAQ,CACRb,OAAO,CAAPA,OAAO,CACPF,KAAK,CAALA,KACF,CAAC,CACH,CAEA,OAASJ,eAAe,EAGxB;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA"},"metadata":{},"sourceType":"module","externalDependencies":[]}