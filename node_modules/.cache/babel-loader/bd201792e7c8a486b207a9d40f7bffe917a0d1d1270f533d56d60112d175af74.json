{"ast":null,"code":"var _s = $RefreshSig$();\nimport React from 'react';\n\n//Podemos empezar a hacer hoooks como queramos\n\nfunction useLocalStorage(itemName, initialValue) {\n  _s();\n  //Cuando tengamos algo de infromaicon dentro de nuestro estado porque ya acabo de cargar entonces pasamos a la aplicacion\n  const [loading, setLoading] = React.useState(true);\n\n  //Cuando tengamos algo de infromaicon dentro de nuestro estado porque ya acabo de cargar entonces pasamos a la aplicacion\n  const [error, setError] = React.useState(false);\n\n  //Ya no traeremos por defecto la informacacion storage si nho lo definido\n  const [item, setItem] = React.useState(initialValue);\n\n  //Lo que haremos es simular que tardara un rato en llegar\n  React.useEffect(() => {\n    //Cantidad de tiempo hasta ejecutar la funcion\n    setTimeout(() => {\n      //Vamos a hacer un try catch, que consiste en una condicion de error, y ejecuta cierta parte de codigo\n\n      try {\n        //Casi siempre las APIS tienen ciertas versiones\n        const localStorageItem = localStorage.getItem(itemName);\n\n        //Crear un primer array vacio con cosas vacias, tenbemos que traer la info guardada en local storage\n        let parsedItem = initialValue;\n\n        //Vemos si tiene informacion\n        if (!localStorageItem) {\n          //Por defecto una lista de todos necesitamos enmviar un string\n          localStorage.setItem(itemName, JSON.stringify(initialValue));\n          parsedItem = [];\n        }\n\n        //Ya tiene algunos todos\n        else {\n          parsedItem = JSON.parse(localStorageItem);\n        }\n\n        //Nuestro estado es el inical al tener un array vacio, lo que hace es dar el nuevo valor en localstorage\n        setTimeout(parsedItem);\n        setLoading(false);\n      } catch (error) {\n        //Tomamos en cuenta que los errores son falsos\n        setError(error);\n      }\n    }, 1000);\n  });\n\n  //Para la persistencia cada cambio debemos llamar nuestro local storage para persistencia\n  const savedItem = newItem => {\n    //Envolvemos a nuestros items por si hay algun error tambien\n    try {\n      //HAY QUE PERSISTIR la informacion\n      const stringifiedItem = JSON.stringify(newItem);\n      //GUardamos nuestra cadena\n      localStorage.setItem(itemName, stringifiedItem);\n      //Debemos evitar la actualizacion de la pagina\n      setItem(newItem);\n    } catch (error) {\n      setError(error);\n    }\n  };\n\n  //Necesitamos retornar localStorage, es importante tomar en cuenta que si hay mas estados que dos en un hook devolvemos un objeto\n  return {\n    item,\n    savedItem,\n    loading,\n    error\n  };\n}\n_s(useLocalStorage, \"hx7Y7bN8jdZVcIP55e9LRaGqhao=\");\nexport { useLocalStorage };","map":{"version":3,"names":["React","useLocalStorage","itemName","initialValue","loading","setLoading","useState","error","setError","item","setItem","useEffect","setTimeout","localStorageItem","localStorage","getItem","parsedItem","JSON","stringify","parse","savedItem","newItem","stringifiedItem"],"sources":["/home/jorgebg/personalProjects/cursoReact/cursoReactIntroduccion/todo-machine/src/TodoContext/useLocalStorage.js"],"sourcesContent":["import React from 'react';\n\n//Podemos empezar a hacer hoooks como queramos\n\nfunction useLocalStorage(itemName, initialValue) {\n    //Cuando tengamos algo de infromaicon dentro de nuestro estado porque ya acabo de cargar entonces pasamos a la aplicacion\n    const [loading, setLoading] = React.useState(true);\n  \n    //Cuando tengamos algo de infromaicon dentro de nuestro estado porque ya acabo de cargar entonces pasamos a la aplicacion\n    const [error, setError] = React.useState(false);\n  \n    //Ya no traeremos por defecto la informacacion storage si nho lo definido\n    const [item, setItem] = React.useState(initialValue);\n  \n    //Lo que haremos es simular que tardara un rato en llegar\n    React.useEffect(() => {\n      //Cantidad de tiempo hasta ejecutar la funcion\n      setTimeout(() => {\n        //Vamos a hacer un try catch, que consiste en una condicion de error, y ejecuta cierta parte de codigo\n  \n        try{\n          //Casi siempre las APIS tienen ciertas versiones\n        const localStorageItem = localStorage.getItem(itemName);\n  \n        //Crear un primer array vacio con cosas vacias, tenbemos que traer la info guardada en local storage\n        let parsedItem = initialValue;\n  \n        //Vemos si tiene informacion\n        if (!localStorageItem) {\n          //Por defecto una lista de todos necesitamos enmviar un string\n          localStorage.setItem(itemName, JSON.stringify(initialValue));\n          parsedItem = [];\n        }\n  \n        //Ya tiene algunos todos\n        else {\n          parsedItem = JSON.parse(localStorageItem);\n        }\n  \n        //Nuestro estado es el inical al tener un array vacio, lo que hace es dar el nuevo valor en localstorage\n        setTimeout(parsedItem);\n        setLoading(false);\n        } catch(error){\n          //Tomamos en cuenta que los errores son falsos\n          setError(error);\n        }\n  \n      }, 1000);\n    });\n  \n  \n  \n    //Para la persistencia cada cambio debemos llamar nuestro local storage para persistencia\n    const savedItem = (newItem) => {\n      //Envolvemos a nuestros items por si hay algun error tambien\n      try{\n        //HAY QUE PERSISTIR la informacion\n      const stringifiedItem = JSON.stringify(newItem);\n      //GUardamos nuestra cadena\n      localStorage.setItem(itemName, stringifiedItem);\n      //Debemos evitar la actualizacion de la pagina\n      setItem(newItem);\n      } catch(error){\n        setError(error);\n      }\n    };\n  \n    //Necesitamos retornar localStorage, es importante tomar en cuenta que si hay mas estados que dos en un hook devolvemos un objeto\n    return {\n      item, \n      savedItem, \n      loading,\n      error,\n    };\n  }\n\n  export { useLocalStorage };"],"mappings":";AAAA,OAAOA,KAAK,MAAM,OAAO;;AAEzB;;AAEA,SAASC,eAAe,CAACC,QAAQ,EAAEC,YAAY,EAAE;EAAA;EAC7C;EACA,MAAM,CAACC,OAAO,EAAEC,UAAU,CAAC,GAAGL,KAAK,CAACM,QAAQ,CAAC,IAAI,CAAC;;EAElD;EACA,MAAM,CAACC,KAAK,EAAEC,QAAQ,CAAC,GAAGR,KAAK,CAACM,QAAQ,CAAC,KAAK,CAAC;;EAE/C;EACA,MAAM,CAACG,IAAI,EAAEC,OAAO,CAAC,GAAGV,KAAK,CAACM,QAAQ,CAACH,YAAY,CAAC;;EAEpD;EACAH,KAAK,CAACW,SAAS,CAAC,MAAM;IACpB;IACAC,UAAU,CAAC,MAAM;MACf;;MAEA,IAAG;QACD;QACF,MAAMC,gBAAgB,GAAGC,YAAY,CAACC,OAAO,CAACb,QAAQ,CAAC;;QAEvD;QACA,IAAIc,UAAU,GAAGb,YAAY;;QAE7B;QACA,IAAI,CAACU,gBAAgB,EAAE;UACrB;UACAC,YAAY,CAACJ,OAAO,CAACR,QAAQ,EAAEe,IAAI,CAACC,SAAS,CAACf,YAAY,CAAC,CAAC;UAC5Da,UAAU,GAAG,EAAE;QACjB;;QAEA;QAAA,KACK;UACHA,UAAU,GAAGC,IAAI,CAACE,KAAK,CAACN,gBAAgB,CAAC;QAC3C;;QAEA;QACAD,UAAU,CAACI,UAAU,CAAC;QACtBX,UAAU,CAAC,KAAK,CAAC;MACjB,CAAC,CAAC,OAAME,KAAK,EAAC;QACZ;QACAC,QAAQ,CAACD,KAAK,CAAC;MACjB;IAEF,CAAC,EAAE,IAAI,CAAC;EACV,CAAC,CAAC;;EAIF;EACA,MAAMa,SAAS,GAAIC,OAAO,IAAK;IAC7B;IACA,IAAG;MACD;MACF,MAAMC,eAAe,GAAGL,IAAI,CAACC,SAAS,CAACG,OAAO,CAAC;MAC/C;MACAP,YAAY,CAACJ,OAAO,CAACR,QAAQ,EAAEoB,eAAe,CAAC;MAC/C;MACAZ,OAAO,CAACW,OAAO,CAAC;IAChB,CAAC,CAAC,OAAMd,KAAK,EAAC;MACZC,QAAQ,CAACD,KAAK,CAAC;IACjB;EACF,CAAC;;EAED;EACA,OAAO;IACLE,IAAI;IACJW,SAAS;IACThB,OAAO;IACPG;EACF,CAAC;AACH;AAAC,GAtEMN,eAAe;AAwEtB,SAASA,eAAe"},"metadata":{},"sourceType":"module","externalDependencies":[]}